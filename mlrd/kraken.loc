module kraken

export KrakenConfig
export krakenU
export krakenReport
export krakenHelp
export krakenVersion

record KrakenConfig = KrakenConfig
  { threads    :: Int  -- Number of threads (default: 1)
  , checkNames :: Bool -- Ensure each pair of reads have names that agree
  , db         :: Str  -- Name for Kraken DB (default: none)
  , minHits    :: Int  -- In quick op., number of hits req'd for classification
  , preload    :: Bool -- Loads DB into memory before classification
  , quick      :: Bool -- Quick operation (use first hit or hits)
  }

-- We currently have to define a language specific type for each language
-- In the future, this may be automatically derived.
record Py KrakenConfig =
  "dict" -- record is stored as a Python dictionary
  { threads    :: "int"  --
  , checkNames :: "bool" -- The python types aligning to each general type
  , db         :: "str"  --
  , minHits    :: "int"  --
  , preload    :: "bool" --
  , quick      :: "bool" --
  }

source Py from "kraken.py"
  (
  , "krakenPaired" as krakenU
  , "krakenReport"
  , "krakenVersion"
  , "krakenHelp"
  )

krakenU
  :: KrakenConfig
  -> db:Filename
  -> r1:Filename
  -> r2:Filename
  -> Table
  -- -- currently unsupported, but in the future names of arguments may be used to specify constraints
  -- where
  --   nrow r1 != norw r2
  --   (r1[4 * (i // 4)] == r2[4 * (i // 4)] forall i <- 0:(nrow r1 - 1))

-- converts a kraken output table to a taxon report table
krakenReport :: KrakenConfig -> Table -> Table

krakenHelp :: () -> Str

krakenVersion :: () -> Str

readKrakenReport :: Filename -> Table

readkKrakenSummary :: Filename -> Table




-- "Table" is a dynamic table with types that are only inferred at runtime. This
-- limits its use in morloc since we can't use any function that is dependent on
-- column type. We can reverse a table, subset the rows by position, or select
-- columns by name. If we want a deeper interface, we will need the typed tables
-- There is experimental support for these. But they are verbose and not well
-- tested.

table KrakenOut = KrakenOut  
    { classified :: Bool
    , sequenceId :: Int
    , taxonomyId :: Int
    , length :: Int
    , lca :: Str
    }

table Py KrakenOut = KrakenOut  
    { classified :: "bool"
    , sequenceId :: "int"
    , taxonomyId :: "int"
    , length :: "int"
    , lca :: "str"
    }

table R KrakenOut = KrakenOut  
    { classified :: "logical"
    , sequenceId :: "integer"
    , taxonomyId :: "integer"
    , length :: "integer"
    , lca :: "character"
    }
